# 代码包和包引入
Go代码包（package）来组织管理代码。 我们必须先引入一个代码包（除了builtin标准库包）才能使用其中导出的代码要素（比如函数、类型、变量和具名常量等）。

## 包引入
一个例子：
```go
package main

import "fmt"

func main() {
	fmt.Println("Go has", 25, "keywords.")
}
```
一个包引入也可称为一个包声明。一个包声明只在当前包含此声明的源文件内可见。

另一个例子：
```go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Printf("下一个伪随机数是%v。\n", rand.Uint32())
}
```
这个例子多引入了一个 `math/rand` 标准库包。 此包是 `math` 标准库包中的一个子包。 

- 在此例中，`math/rand` 标准库包的引入名是 `rand`。 `rand.Uint32()` 函数调用将返回一个uint32类型的随机数。
- `Printf` 函数是 `fmt` 标准库包中提供的另外一个常用终端打印函数。 一个 `Printf` 函数调用必须带有至少一个实参，并且第一个实参的类型必须为 `string`。 此第一个实参指定了此调用的打印格式。此格式中的 `%v` 在打印结果将被对应的后续实参的字符串表示形式所取代。比如上列中的 `%v` 在打印结果中将被 `rand.Uint32()` 函数调用所返回的随机数所取代。 打印格式中的 `\n` 表示一个换行符

### 更多关于fmt.Printf函数调用的输出格式
- 常用的占位字符组合：
- %v：将被替换为对应实参字符串表示形式。
- %T：将替换为对应实参的类型的字符串表示形式。
- %x：将替换为对应实参的十六进制表示。实参的类型可以为字符串、整数、整数数组（array）或者整数切片（slice）等。 （数组和切片将在以后的文章中讲解。）
- %s：将被替换为对应实参的字符串表示形式。实参的类型必须为字符串或者字节切片（byte slice）类型。
- %%：将被替换为一个百分号。

## main 代码包
一个程序中含有main入口函数的名称为main的代码包为程序代码包（或者命令代
码包），称其它代码包为库代码包。 程序代码包不能被其它代码包引入。一个程序只能有一个程
序代码包

## init 函数
在一个代码包中，甚至一个源文件中，可以声明若干名为 `init` 的函数。 这些 `init` 函数必须不带任何输入参数和返回结果。
> 注意：我们不能声明名为 `init` 的包级变量、常量或者类型。

在程序运行时刻，在进入 `main` 入口函数之前，每个 `init` 函数在此包加载的时候将被（串行）执行并且只执行一遍。

下面这个简单的程序中有两个 `init` 函数：
```go
package main

import "fmt"

func init() {
	fmt.Println("hi,", bob)
}

func main() {
	fmt.Println("bye")
}

func init() {
	fmt.Println("hello,", smith)
}

func titledName(who string) string {
	return "Mr. " + who
}

var bob, smith = titledName("Bob"), titledName("Smith")

// hi, Mr. Bob
// hello, Mr. Smith
// bye
```

## 程序代码要素初始化顺序
一个程序中所涉及到的所有的在运行时刻要用到的代码包的加载是串行执行的。 在一个程序启动时，每个包中总是在它所有依赖的包都加载完成之后才开始加载。 程序代码包总是最后一个被加载的代码包。每个被用到的包会被而且仅会被加载一次。

在加载一个代码包的过程中，所有的声明在此包中的init函数将被串行调用并且仅调用执行一
次。 一个代码包中声明的init函数的调用肯定晚于此代码包所依赖的代码包中声明的init函数。 所有的init函数都将在调用main入口函数之前被调用执行。

在同一个源文件中声明的init函数将按从上到下的顺序被调用执行。 对于声明在同一个包中的两个不同源文件中的两个init函数，Go语言白皮书推荐（但不强求）按照它们所处于的源文件的名称的词典序列（对英文来说，即字母顺序）来调用。 所以最好不要让声明在同一个包中的两个不同源文件中的两个init函数存在依赖关系。

在加载一个代码包的时候，此代码包中声明的所有包级变量都将在此包中的任何一个init函数执行之前初始化完毕。

在同一个包内，包级变量将尽量按照它们在代码中的出现顺序被初始化，但是一个包级变量的初始化肯定晚于它所依赖的其它包级变量。 比如，在下面的代码片段中，四个包级变量的初始化顺序依次为y、z、x、w。

## 完整的引入声明语句形式
一个引入声明语句的完整形式为：
```go
import importname "path/to/package" 
```
其中引入名importname是可选的，它的默认值为被引入的包的包名（不是目录名）。类似Python的  `import package as packagename`

名importname可以是一个句点(.)。 这样的引入称为句点引入。使用被句点引入的包中的导出代码要素时，限定标识符的前缀必须省略。类似于Python的 `from package import *`
> 一般来说，句点引入不推荐使用，因为它们会导致较低的代码可读性。

名importname可以是一个空标识符( `_` )。 这样的引入称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的代码要素得以初始化。 被匿名引入的包中的 `init` 函数将被执行并且仅执行一遍

## 每个非匿名引入必须至少被使用一次
除了匿名引入，其它引入必须在代码中被使用一次。 比如，下面的程序编译不通过。
```go
package main

import (
	. "time" // error: 引入未被使用

	format "fmt"  // okay: 下面被使用了一次
	_ "math/rand" // okay: 匿名引入
)

func main() {

	format.Println() // 使用"fmt"包
}
```

## 模块
一个模块（module）为的若干代码包的集合。当被下载至本地后，这些代码包处于同一个目录（此模块的根目录）下。 一个模块可以有很多版本（版本号遵从范）。

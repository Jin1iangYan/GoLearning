# 常量和变量
这篇文章将介绍常量和变量相关的知识。 类型不确定值、类型推断和值的显式类型转换等概念也将被介绍。

## 类型不确定值（untyped value）和类型确定值（typed value）
在Go中，有些值的类型是不确定的。换句话说，有些值的类型有很多可能性。 这些值称为类型不
确定值。对于大多数类型不确定值来说，它们各自都有一个默认类型， 除了预声明的 `nil`。`nil`
是没有默认类型的。 

与类型不确定值相对应的概念称为类型确定值。
上一章提到的字面常量（无名常量）都属于类型不确定值。 事实上，Go中大多数的类型不确定值
都属于字面常量和本文即将介绍的具名常量。 少数类型不确定值包括刚提到的 `nil` 和以后会逐步
接触到的某些操作的布尔返回值。

一个字面（常）量的默认类型取决于它为何种字面量形式：
- 一个字符串字面量的默认类型是预声明的string类型。
- 一个布尔字面量的默认类型是预声明的bool类型。
- 一个整数型字面量的默认类型是预声明的int类型。
- 一个rune字面量的默认类型是预声明的rune（亦即int32）类型。
- 一个浮点数字面量的默认类型是预声明的float64类型。
- 如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的complex128类型。

### 类型不确定常量的显式类型转换
语法：`T(v)`，其表示将一个值 `v` 转换为类型 `T`。 

对于一个类型不确定常量值v，有两种情形显式转换`T(v)`是合法的：
1. `v` 可以表示为（第6章）`T` 类型的一个值。 转换结果为一个类型为 `T` 的类型确定常量值。
2. `v` 的默认类型是一个整数类型（`int` 或者 `rune`） 并且 `T` 是一个字符串类型。 转换`T(v)`将
 `v` 看作是一个Unicode码点。 转换结果为一个类型为T的字符串常量。 此字符串常量只包含
一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 对于不在合法的
Unicode码点取值范围内的整数 `v`， 转换结果等同于字符串字面量 `"\uFFFD"`（亦
即 `"\xef\xbf\xbd"`）。 `0xFFFD` 是Unicode标准中的（非法码点的）替换字符值。 （但
是请注意，今后的Go版本可能只允许 `rune` 或者 `byte` 整数被转换为字符串。 从Go官方工具
链1.15版本开始，go vet命令会对从非 `rune` 和非 `byte` 整数到字符串的转换做出警告。）
> 事实上，第二种情形并不要求 `v` 必须是一个常量。 如果 `v` 是一个常量，则转换结果也是一个常
量。 如果 `v` 不是一个常量，则转换结果也不是一个常量。

[示例代码](./type-convert-demo.go)

## 类型推断介绍
1. 运算符运算、函数调用和赋值语句中编译器推断
2. 有些场景对某些类型不确定值并没有特定的类型要求。在这种情况下，Go编译器将这些类型不确
定值视为它们各自的默认类型的类型确定值。

> 上述两条类型推断规则可以被视为隐式转换规则。

## （具名）常量声明（constant declaration）
用 `const` 关键字声明
```go
package main

// 声明了两个单独的具名常量。（是的，
// 非ASCII字符可以用做标识符。）
const π = 3.1416
const Pi = π // 等价于：const Pi = 3.1416

// 声明了一组具名常量。
const (
No = !Yes
Yes = true
MaxDegrees = 360
Unit = "弧度"
)

func main() {
// 声明了三个局部具名常量。
const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
}
```
> 常量声明中的等号 `=` 表示“绑定”而非“赋值”

### 类型确定具名常量
类型放在变量后面
```go
const X float32 = 3.14

const (
    A, B int64 = -3, 5
    Y float32 = 2.718
)
```
或者使用显式类型转换
```go
const X = float32(3.14)

const (
    A, B = int64(-3), int64(5)
    Y = float32(2.718)
)
```
欲将一个字面常量绑定到一个类型确定具名常量上，此字面常量必须能够表示为此常量的确定类
型的值。 否则，编译将报错。
```go
const a uint8 = 256 // error: 256溢出uint8
const b = uint8(255) + uint8(1) // error: 256溢出uint8
const c = int8(-128) / int8(-1) // error: 128溢出int8
const MaxUint_a = uint(^0) // error: -1溢出uint
const MaxUint_b uint = ^0 // error: -1溢出uint
```

### 常量声明中的自动补全&iota
略

## 变量声明和赋值操作语句
Go语言有两种变量声明形式。一种称为标准形式，另一种称为短声明形式。 短声明形式只能用来
声明局部变量。
### 标准变量声明形式
```go
var lang, website string = "Go", "https://golang.org"
var compiled, dynamic bool = true, false
var announceYear int = 2009
```
省略变量类型
```go
var lang, dynamic = "Go", false
var compiled, announceYear = true, 2009
var website = "https://golang.org"
```
省略初始值
```go
var lang, website string      // 两者都被初始化为空字符串。
var interpreted, dynamic bool // 两者都被初始化为false。
var n int                     // 被初始化为0。
```
和常量声明一样，多个变量可以用一对小括号组团在一起被声明。
```go
var (
    lang, bornYear, compiled = "Go", 2007, true
    announceAt, releaseAt int = 2009, 2012
    createdBy, website string
)
```
### 纯赋值语句
一个包含了很多（合法或者不合法的）纯赋值语句的例子：
```go
const N = 123
var x int
var y, z float32

N = 789 // error: N是一个不可变量
y = N // ok: N被隐式转换为类型float32
x = y // error: 类型不匹配
x = N // ok: N被隐式转换为类型int
y = x // error: 类型不匹配
z = y // ok
_ = y // ok

z, y = y, z // ok
_, y = y, z // ok
z, _ = y, z // ok
_, _ = y, z // ok
x, y = 69, 1.23 // ok
x, y = y, x // error: 类型不匹配
x, y = int(y), float32(x) // ok
```
> Go不支持某些其它语言中的连等语法。

### 短变量声明形式
用短变量声明形式来声明一些局部变量。比如下例：
```go
package main

func main() {
// 变量lang和year都为新声明的变量。
lang, year := "Go language", 2007

// 这里，只有变量createdBy是新声明的变量。
// 变量year已经在上面声明过了，所以这里仅仅
// 改变了它的值，或者说它被重新声明了。
year, createdBy := 2009, "Google Research"

// 这是一个纯赋值语句。
lang, year = "Go", 2012

print(lang, "由", createdBy, "发明")
print("并发布于", year, "年。")
println()
}
```
> 每个短声明语句中必须至少有一个新声明的变量。

到短变量声明形式和标准变量声明形式有几个显著的区别：
1. 短声明形式不包含 `var` 关键字，并且不能指定变量的类型。
2. 短变量声明中的赋值符号必须为 `:=`。
3. 在一个短声明语句的左侧，已经声明过的变量和新声明的变量可以共存。 但在一个标准声明语句中，所有出现在左侧的变量必须都为新声明的变量。

> 注意，相对于纯赋值语句，目前短声明语句有一个限制：出现在一个短声明左侧的项必须都为纯
标识符。 以后我们将学习到在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器
类型值的元素索引项等。 但是这些项不能出现在一个变量短声明语句的左边。
>
> - 纯标识符：x, y, fooBar
> - 不纯标识符（包括更多复杂的表达式）：
>   - 结构体字段：person.name
>   - 指针解引用：*ptr
>   - 容器类型值的元素索引：arr[0]
>
> 只是便于理解，官方并没有不纯标识符这种术语

### 关于“赋值”这个术语
以后，当“赋值”这个术语被提到的时候，它可以指一个**纯赋值**、一个**短变量声明**或者一个**初始值未省略的标准变量声明**。 事实上，一个更通用的定义包括后续文章将要介绍的函数传参。

当 `y = x` 是一条合法的赋值语句时，我们可以说 `x` 可以被赋给 `y`。 假设 `y` 的类型为 `Ty`，有时为了叙述方便，我们也可以说 `x` 可以被赋给类型 `Ty`。

一般来说，如果 `x` 可以被赋给 `y`，则 `y` 应该是可修改的，并且 `x` 和 `y` 的类型相同或者 `x` 可以被隐式转换到 `y` 的类型。 当然，`y` 也可以是空标识符 `_`。

### 每个局部声明的变量至少要被有效使用一次
注意，当使用目前的主流Go编译器编译Go代码时，一个局部变量被声明之后至少要被有效使用一次，否则编译器将报错。 包级变量无此限制。 

避免编译器报错的方法：
- 删除相关的变量声明
- 将未曾有效使用过的变量赋给空标识符 `_`。
    - `_, _ = r, s // 将r和s做为源值使用一次。`

### 若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序
下面这个例子中的声明的变量的初始化顺序为 `y = 5`、`c = y`、`b = c+1`、`a = b+1`、`x =a+1`。
```go
var x, y = a+1, 5 // 8 5
var a, b, c = b+1, c+1, y // 7 6 5
```
> 包级变量在初始化的时候不能相互依赖：var x, y = y, x

## 值的可寻址性
在Go中，有些值是可以被寻址的。上面已经提到所有变量都是可以寻址的，所有常量都是不可被寻址。 我们可以从后面的指针一文了解更多关于内存地址和指针的知识。

## 非常量数字值相关的显式类型转换规则
两个不同类型数字值之间的转换规则：
- 一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型。
- 一个非常量复数可以显式转换到其它任何一个复数类型。

关于溢出：
- 常量数字值的类型转换不能溢出（Error）
- 非常量数字值的类型转换中，溢出是允许的。
- 另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的
- 具体规则如下：
    - 当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。我们称这种处理方式为截断（truncated）。
    - 当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的小数部分将被舍弃（向零靠拢）。
    - 当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
    - 当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。
    - 当一个显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）。

[示例代码](./non-constant-numeric-conversion.go)

## 变量和常量的作用域
最外层的代码块称为包级代码块。 一个声明在一个内层代码块中的常量或者变量将遮挡另一个外层代码块中声明的同名变量或者常量。 

一个局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾。 

```go
package main

const y = 70

var x int = 123 // 包级变量

func main() {
	// 此x变量遮挡了包级变量x。
	var x = true

	// 一个内嵌代码块。
	{
		x, y := x, y-10 // 这里，左边的x和y均为新声明
		// 的变量。右边的x为外层声明的
		// bool变量。右边的y为包级变量。

		// 在此内层代码块中，从此开始，
		// 刚声明的x和y将遮挡外层声明x和y。

		x, z := !x, y/10 // z是一个新声明的变量。
		// x和y是上一句中声明的变量。
		println(x, y, z) // false 60 6
	}
	println(x) // true
	println(y) // 70 （包级变量y从未修改）
	/*
	   println(z) // error: z未定义。
	   // z的作用域仅限于上面的最内层代码块。
	*/
}
```

## 更多关于常量声明
### 一个类型不确定常量所表示的值可以溢出其默认类型
```go
package main

// 三个类型不确定常量。
const n = 1 << 64          // 默认类型为int
const r = 'a' + 0x7FFFFFFF // 默认类型为rune
const x = 2e+308           // 默认类型为float64

func main() {}

```
但是下面这个程序编译不通过，因为三个声明的常量为类型确定常量。
```go
package main

// 三个类型确定常量。
const n int = 1 << 64 // error: 溢出int
const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
const x float64 = 2e+308 // error: 溢出float64

func main() {}
```

### 每个常量标识符将在编译的时候被其绑定的字面量所替代
常量声明可以看作是增强型的C语言中的#define宏。 在编译阶段，所有的标识符将被它们各自绑定的字面量所替代。

如果一个运算中的所有运算数都为常量，则此运算的结果也为常量。或者说，此运算将在编译阶
段就被估值。

一个例子：
```go
package main

const X = 3
const Y = X + X

var a = X

func main() {
	b := Y
	println(a, b, X, Y)
}
```
上面这段程序代码将在编译阶段被重写为下面这样：
```go
package main

var a = 3

func main() {
	b := 6
	println(a, b, 3, 6)
}

```

# 运算操作符
## 关于溢出
- 一个类型确定数字型常量所表示的值是不能溢出它的类型的表示范围的。
- 一个类型不确定数字型常量所表示的值是可以溢出它的默认类型的表示范围的。 当一个类型不确定数字常量值溢出它的默认类型的表示范围时，此数值不会被截断（亦即回绕）。
- 将一个非常量数字值转换为其它数字类型时，此非常量数字值可以溢出转化结果的类型。在此转换中，当溢出发生时，转化结果为此非常量数字值的截断（亦即回绕）表示。

## 关于算术运算的结果

- 如果只有一个操作数是类型确定的，则此运算的结果也是一个和此类型确定操作数类型相同的类型确定值。 另一个类型不确定操作数的类型将被推断为（或隐式转换为）此类型确定操作数的类型。
- 如果它的两个操作数均为类型不确定值，则此运算的结果也是一个类型不确定值。 在运算中，两个操作数的类型将被设想为它们的默认类型中一个（按照此优先级来选择：complex128高于float64高于rune高于int）。 结果的默认类型同样为此设想类型。比如，如果一个类型不确定操作数的默认类型为int，另一个类型不确定操作数的默认类型为rune， 则前者的类型在运算中也被视为rune，运算结果为一个默认类型为rune的类型不确定值。

```go
func main() {
	// 三个类型不确定常量。它们的默认类型
	// 分别为：int、rune和complex64.
	const X, Y, Z = 2, 'A', 3i

	var a, b int = X, Y // 两个类型确定值

	// 变量d的类型被推断为Y的默认类型：rune（亦即int32）。
	d := X + Y
	// 变量e的类型被推断为a的类型：int。
	e := Y - a
	// 变量f的类型和a及b的类型一样：int。
	f := a * b
	// 变量g的类型被推断为Z的默认类型：complex64。
	g := Z * Y

	// 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
```
对于移位运算，结果规则有点小复杂。我不想学。

## 支持字符串衔接运算符
```go
println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
```

## 更多关于常量表达式
常量子表达式的顺序有可能影响到最终的估值结果。

```go
package main

import "fmt"

const x = 3 / 2 * 0.1
const y = 0.1 * 3 / 2

var z1 = 1.2 + 3/2
var z2 = 1.2 + 3/2.0

func main() {
	fmt.Printf("x: %v\n", x)
	fmt.Printf("y: %v\n", y)

	fmt.Printf("z1: %v\n", z1)
	fmt.Printf("z2: %v\n", z2)

	// x: 0.1
	// y: 0.15
	// z1: 2.2
	// z2: 2.7
}

```

## 更多其他操作符
之后介绍
